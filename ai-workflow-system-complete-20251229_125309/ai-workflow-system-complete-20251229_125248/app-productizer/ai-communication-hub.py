#!/usr/bin/env python3
"""
AI Communication Hub - Multi-Channel AI-to-AI Communication System
Creates multiple channels for AIs to communicate with each other asynchronously
"""

import json
import os
import requests
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional

class AIMessage:
    """Standard AI message format for cross-AI communication"""
    
    def __init__(self, from_ai: str, to_ai: str, message: str, 
                 message_type: str = "general", priority: str = "normal"):
        self.id = f"msg_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{from_ai[:3]}"
        self.timestamp = datetime.now().isoformat()
        self.from_ai = from_ai
        self.to_ai = to_ai
        self.message = message
        self.message_type = message_type  # general, task, question, response, alert
        self.priority = priority  # low, normal, high, urgent
        self.status = "pending"  # pending, read, responded
        
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "timestamp": self.timestamp,
            "from_ai": self.from_ai,
            "to_ai": self.to_ai,
            "message": self.message,
            "message_type": self.message_type,
            "priority": self.priority,
            "status": self.status
        }

class MultiChannelAICommunicator:
    """
    Multi-channel communication system for AI-to-AI messaging
    Uses GitHub, Notion, Zapier, files, and other creative methods
    """
    
    def __init__(self):
        self.channels = {
            "github_issues": GitHubIssueChannel(),
            "github_discussions": GitHubDiscussionChannel(),
            "file_system": FileSystemChannel(),
            "notion_database": NotionChannel(),
            "zapier_webhook": ZapierChannel(),
            "email_bridge": EmailChannel(),
            "json_bulletin": JSONBulletinChannel()
        }
        
        # Initialize session tracking
        self.session_tracker = SessionTracker()
        
    def send_message(self, message: AIMessage, channels: List[str] = None) -> Dict[str, bool]:
        """Send message through specified channels (or all if none specified)"""
        
        if channels is None:
            channels = list(self.channels.keys())
        
        results = {}
        
        for channel_name in channels:
            if channel_name in self.channels:
                try:
                    success = self.channels[channel_name].send(message)
                    results[channel_name] = success
                    print(f"ğŸ“¤ {channel_name}: {'âœ… Sent' if success else 'âŒ Failed'}")
                except Exception as e:
                    results[channel_name] = False
                    print(f"ğŸ“¤ {channel_name}: âŒ Error - {e}")
            else:
                results[channel_name] = False
                print(f"ğŸ“¤ {channel_name}: âŒ Unknown channel")
        
        # Log to session tracker
        self.session_tracker.log_message_sent(message, results)
        
        return results
class GitHubIssueChannel:
    """Communicate via GitHub Issues - perfect for task assignments and discussions"""
    
    def __init__(self):
        self.repo_owner = "issdandavis"  # Your GitHub username
        self.repo_name = "AI-Agent-Workflow"  # Your repo name
        self.github_token = os.getenv('GITHUB_TOKEN', '')
        
    def send(self, message: AIMessage) -> bool:
        """Create GitHub issue for AI communication"""
        
        # Create issue title and body
        title = f"[AI-COMM] {message.from_ai} â†’ {message.to_ai}: {message.message_type.title()}"
        
        body = f"""## AI-to-AI Communication Message

**From AI**: {message.from_ai}
**To AI**: {message.to_ai}
**Message Type**: {message.message_type}
**Priority**: {message.priority}
**Timestamp**: {message.timestamp}
**Message ID**: {message.id}

---

### Message Content
{message.message}

---

### Instructions for Receiving AI
- This is an automated message from another AI system
- Please respond by commenting on this issue
- Mark as closed when task is complete
- Use the Universal Language Codex for any translations needed

### Universal Codex Available
The receiving AI has access to the Universal Language Codex for translating between:
- Programming Languages: Python, JavaScript, Go, Rust, C#, Java
- Sacred Tongues: Kor'aelin, Avali, Runethic, Cassisivadan, Umbroth, Draumric

---
*Generated by AI Communication Hub - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

        # Create issue via GitHub API (if token available)
        if self.github_token:
            try:
                url = f"https://api.github.com/repos/{self.repo_owner}/{self.repo_name}/issues"
                headers = {
                    "Authorization": f"token {self.github_token}",
                    "Accept": "application/vnd.github.v3+json"
                }
                data = {
                    "title": title,
                    "body": body,
                    "labels": ["ai-communication", f"from-{message.from_ai}", f"to-{message.to_ai}", message.priority]
                }
                
                response = requests.post(url, headers=headers, json=data)
                return response.status_code == 201
            except Exception as e:
                print(f"GitHub API error: {e}")
                return False
        else:
            # Fallback: Create local file that can be manually created as issue
            issue_file = Path(f"AI_GITHUB_ISSUES/issue_{message.id}.md")
            issue_file.parent.mkdir(exist_ok=True)
            
            with open(issue_file, 'w') as f:
                f.write(f"# {title}\n\n{body}")
            
            print(f"ğŸ“ GitHub issue template saved: {issue_file}")
            print(f"ğŸ’¡ Manually create issue at: https://github.com/{self.repo_owner}/{self.repo_name}/issues/new")
            return True

class FileSystemChannel:
    """Communicate via shared file system - simple and reliable"""
    
    def __init__(self):
        self.message_dir = Path("AI_MESSAGES")
        self.message_dir.mkdir(exist_ok=True)
        
    def send(self, message: AIMessage) -> bool:
        """Save message to file system"""
        
        # Create message file
        message_file = self.message_dir / f"{message.id}.json"
        
        with open(message_file, 'w') as f:
            json.dump(message.to_dict(), f, indent=2)
        
        # Create inbox for receiving AI
        inbox_dir = self.message_dir / "inboxes" / message.to_ai
        inbox_dir.mkdir(parents=True, exist_ok=True)
        
        # Create symlink or copy to inbox
        inbox_file = inbox_dir / f"{message.id}.json"
        try:
            inbox_file.symlink_to(message_file.absolute())
        except:
            # Fallback to copy if symlinks not supported
            with open(inbox_file, 'w') as f:
                json.dump(message.to_dict(), f, indent=2)
        
        return True

class NotionChannel:
    """Communicate via Notion database - great for structured data"""
    
    def __init__(self):
        self.notion_token = os.getenv('NOTION_TOKEN', '')
        self.database_id = os.getenv('NOTION_AI_COMM_DB', '')
        
    def send(self, message: AIMessage) -> bool:
        """Add message to Notion database"""
        
        if not self.notion_token or not self.database_id:
            # Fallback: Create local Notion template
            notion_file = Path(f"AI_NOTION_MESSAGES/notion_{message.id}.json")
            notion_file.parent.mkdir(exist_ok=True)
            
            notion_data = {
                "database_id": "YOUR_NOTION_DATABASE_ID",
                "properties": {
                    "Title": {"title": [{"text": {"content": f"{message.from_ai} â†’ {message.to_ai}"}}]},
                    "From AI": {"rich_text": [{"text": {"content": message.from_ai}}]},
                    "To AI": {"rich_text": [{"text": {"content": message.to_ai}}]},
                    "Message Type": {"select": {"name": message.message_type}},
                    "Priority": {"select": {"name": message.priority}},
                    "Status": {"select": {"name": message.status}},
                    "Message": {"rich_text": [{"text": {"content": message.message}}]},
                    "Timestamp": {"date": {"start": message.timestamp}}
                }
            }
            
            with open(notion_file, 'w') as f:
                json.dump(notion_data, f, indent=2)
            
            print(f"ğŸ“ Notion template saved: {notion_file}")
            print(f"ğŸ’¡ Add to Notion: https://api.notion.com/v1/pages")
            return True
        
        # TODO: Implement actual Notion API call
        return False

class ZapierChannel:
    """Communicate via Zapier webhook - connects to everything"""
    
    def __init__(self):
        self.webhook_url = os.getenv('ZAPIER_AI_COMM_WEBHOOK', '')
        
    def send(self, message: AIMessage) -> bool:
        """Send message via Zapier webhook"""
        
        if not self.webhook_url:
            # Create webhook template
            webhook_file = Path(f"AI_ZAPIER_WEBHOOKS/webhook_{message.id}.json")
            webhook_file.parent.mkdir(exist_ok=True)
            
            webhook_data = {
                "webhook_url": "YOUR_ZAPIER_WEBHOOK_URL",
                "payload": message.to_dict(),
                "suggested_zaps": [
                    "Send to Slack channel",
                    "Add to Google Sheets",
                    "Send email notification",
                    "Create Trello card",
                    "Post to Discord"
                ]
            }
            
            with open(webhook_file, 'w') as f:
                json.dump(webhook_data, f, indent=2)
            
            print(f"ğŸ“ Zapier webhook template saved: {webhook_file}")
            return True
        
        try:
            response = requests.post(self.webhook_url, json=message.to_dict())
            return response.status_code == 200
        except Exception as e:
            print(f"Zapier webhook error: {e}")
            return False
class EmailChannel:
    """Communicate via email - universal and reliable"""
    
    def send(self, message: AIMessage) -> bool:
        """Create email template for AI communication"""
        
        email_file = Path(f"AI_EMAIL_MESSAGES/email_{message.id}.txt")
        email_file.parent.mkdir(exist_ok=True)
        
        email_content = f"""To: {message.to_ai}@ai-systems.local
From: {message.from_ai}@ai-systems.local
Subject: [AI-COMM] {message.message_type.title()} - Priority: {message.priority}

AI-to-AI Communication Message
==============================

Message ID: {message.id}
Timestamp: {message.timestamp}
From AI: {message.from_ai}
To AI: {message.to_ai}
Type: {message.message_type}
Priority: {message.priority}

Message:
--------
{message.message}

Instructions:
------------
- This is an automated message from another AI system
- Please respond via the same communication channels
- Use Universal Language Codex for any translations
- Mark as complete when task is finished

Universal Codex Available:
- Programming: Python, JavaScript, Go, Rust, C#, Java
- Sacred Tongues: Kor'aelin, Avali, Runethic, Cassisivadan, Umbroth, Draumric

---
Generated by AI Communication Hub
"""
        
        with open(email_file, 'w') as f:
            f.write(email_content)
        
        return True

class JSONBulletinChannel:
    """JSON bulletin board - simple shared message board"""
    
    def __init__(self):
        self.bulletin_file = Path("AI_BULLETIN_BOARD.json")
        
    def send(self, message: AIMessage) -> bool:
        """Add message to JSON bulletin board"""
        
        # Load existing bulletin
        if self.bulletin_file.exists():
            with open(self.bulletin_file, 'r') as f:
                bulletin = json.load(f)
        else:
            bulletin = {
                "created": datetime.now().isoformat(),
                "description": "AI-to-AI Communication Bulletin Board",
                "messages": []
            }
        
        # Add new message
        bulletin["messages"].append(message.to_dict())
        bulletin["last_updated"] = datetime.now().isoformat()
        
        # Save bulletin
        with open(self.bulletin_file, 'w') as f:
            json.dump(bulletin, f, indent=2)
        
        return True

class GitHubDiscussionChannel:
    """Use GitHub Discussions for threaded AI conversations"""
    
    def send(self, message: AIMessage) -> bool:
        """Create GitHub discussion template"""
        
        discussion_file = Path(f"AI_GITHUB_DISCUSSIONS/discussion_{message.id}.md")
        discussion_file.parent.mkdir(exist_ok=True)
        
        discussion_content = f"""# AI Communication: {message.from_ai} â†’ {message.to_ai}

**Category**: AI-to-AI Communication
**Labels**: ai-comm, {message.message_type}, {message.priority}

## Message Details
- **From**: {message.from_ai}
- **To**: {message.to_ai}
- **Type**: {message.message_type}
- **Priority**: {message.priority}
- **Timestamp**: {message.timestamp}
- **ID**: {message.id}

## Message Content
{message.message}

## For Receiving AI
Please respond in this discussion thread. Use the Universal Language Codex for any translations between the 12 supported languages.

---
*Auto-generated AI communication message*
"""
        
        with open(discussion_file, 'w') as f:
            f.write(discussion_content)
        
        return True

class SessionTracker:
    """Track AI session activities and plans"""
    
    def __init__(self):
        self.session_file = Path("AI_SESSION_LOG.json")
        self.session_data = self.load_session()
        
    def load_session(self) -> Dict[str, Any]:
        """Load existing session data"""
        
        if self.session_file.exists():
            with open(self.session_file, 'r') as f:
                return json.load(f)
        else:
            return {
                "session_start": datetime.now().isoformat(),
                "activities_completed": [],
                "activities_planned": [],
                "messages_sent": [],
                "ai_participants": [],
                "achievements": [],
                "next_steps": []
            }
    
    def save_session(self):
        """Save session data"""
        
        self.session_data["last_updated"] = datetime.now().isoformat()
        
        with open(self.session_file, 'w') as f:
            json.dump(self.session_data, f, indent=2)
    
    def log_activity_completed(self, activity: str, details: str = ""):
        """Log completed activity"""
        
        self.session_data["activities_completed"].append({
            "timestamp": datetime.now().isoformat(),
            "activity": activity,
            "details": details
        })
        self.save_session()
    
    def log_activity_planned(self, activity: str, priority: str = "normal"):
        """Log planned activity"""
        
        self.session_data["activities_planned"].append({
            "activity": activity,
            "priority": priority,
            "added": datetime.now().isoformat()
        })
        self.save_session()
    
    def log_message_sent(self, message: AIMessage, results: Dict[str, bool]):
        """Log sent message"""
        
        self.session_data["messages_sent"].append({
            "message_id": message.id,
            "from_ai": message.from_ai,
            "to_ai": message.to_ai,
            "channels": results,
            "timestamp": message.timestamp
        })
        
        # Track AI participants
        if message.from_ai not in self.session_data["ai_participants"]:
            self.session_data["ai_participants"].append(message.from_ai)
        if message.to_ai not in self.session_data["ai_participants"]:
            self.session_data["ai_participants"].append(message.to_ai)
        
        self.save_session()
    
    def add_achievement(self, achievement: str):
        """Add achievement"""
        
        self.session_data["achievements"].append({
            "achievement": achievement,
            "timestamp": datetime.now().isoformat()
        })
        self.save_session()
    
    def add_next_step(self, step: str, priority: str = "normal"):
        """Add next step"""
        
        self.session_data["next_steps"].append({
            "step": step,
            "priority": priority,
            "added": datetime.now().isoformat()
        })
        self.save_session()
    
    def get_session_summary(self) -> str:
        """Get formatted session summary"""
        
        summary = f"""
# AI Session Summary

**Session Started**: {self.session_data['session_start']}
**Last Updated**: {self.session_data.get('last_updated', 'Never')}
**AI Participants**: {len(self.session_data['ai_participants'])}

## Completed Activities ({len(self.session_data['activities_completed'])})
"""
        
        for activity in self.session_data['activities_completed'][-5:]:  # Last 5
            summary += f"- âœ… {activity['activity']} ({activity['timestamp']})\n"
        
        summary += f"\n## Planned Activities ({len(self.session_data['activities_planned'])})\n"
        
        for activity in self.session_data['activities_planned']:
            priority_emoji = {"high": "ğŸ”¥", "normal": "ğŸ“‹", "low": "ğŸ’¡"}.get(activity['priority'], "ğŸ“‹")
            summary += f"- {priority_emoji} {activity['activity']}\n"
        
        summary += f"\n## Messages Sent ({len(self.session_data['messages_sent'])})\n"
        
        for msg in self.session_data['messages_sent'][-3:]:  # Last 3
            summary += f"- ğŸ“¤ {msg['from_ai']} â†’ {msg['to_ai']} ({msg['message_id']})\n"
        
        summary += f"\n## Achievements ({len(self.session_data['achievements'])})\n"
        
        for achievement in self.session_data['achievements']:
            summary += f"- ğŸ† {achievement['achievement']}\n"
        
        summary += f"\n## Next Steps ({len(self.session_data['next_steps'])})\n"
        
        for step in self.session_data['next_steps']:
            priority_emoji = {"high": "ğŸ”¥", "normal": "ğŸ“‹", "low": "ğŸ’¡"}.get(step['priority'], "ğŸ“‹")
            summary += f"- {priority_emoji} {step['step']}\n"
        
        return summary